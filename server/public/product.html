<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Women in Black – Product</title>
<style>
  :root { --gap: clamp(12px, 2vw, 24px); }
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111; background:#fafafa; }
  .wrap { max-width: 1200px; margin:0 auto; padding: var(--gap); }

  .grid {
    display:grid;
    grid-template-columns: 1fr;
    gap: var(--gap);
  }
  @media (min-width: 860px) {
    .grid { grid-template-columns: 1.1fr .9fr; align-items:start; }
  }

  /* Wall + canvas area */
  .wall {
    position: relative;
    border-radius: 12px;
    padding: clamp(10px, 2vw, 28px);
    background:
      radial-gradient(1400px 700px at 30% 0%, rgba(255,255,255,.95), rgba(255,255,255,.55) 40%, rgba(236,236,236,.7)),
      linear-gradient(180deg, #f3f4f6 0%, #e9ebee 100%);
    box-shadow: inset 0 24px 42px rgba(0,0,0,.05);
  }
  #framePreview {
    width: 100%;
    height: auto;
    display: block;
    aspect-ratio: 4/5; /* JS corrects after image load */
    background: transparent;
    border-radius: 10px;
  }

  /* Product side */
  .title { font-size: clamp(22px, 3vw, 36px); font-weight: 700; margin: 0; }
  .price { font-size: clamp(18px, 2.2vw, 22px); color:#444; margin:.15rem 0 1rem }
  .opt { margin: 1rem 0; }
  label { font-weight:600; display:block; margin-bottom:.35rem; }
  select, button {
    padding: .6rem .8rem;
    border-radius: 10px;
    border:1px solid #d1d5db;
    background:#fff;
    font: inherit;
  }
  button {
    background:#111; color:#fff; border-color:#111; cursor:pointer; margin-top:1rem;
  }
  button:hover { filter: brightness(1.05); }
  .copy { color:#444; line-height:1.55; }
</style>
</head>
<body>
  <main class="wrap">
    <div class="grid">

      <!-- LEFT: Realistic framed preview -->
      <section aria-label="Artwork preview on wall">
        <div class="wall">
          <canvas id="framePreview" aria-label="Framed artwork preview"></canvas>
        </div>
      </section>

      <!-- RIGHT: Product info + options -->
      <section>
        <h1 class="title">Women in Black</h1>
        <div class="price">From £39</div>

        <!-- If you already have a dropdown in your theme, just add data-role="frame-color" to it -->
        <div class="opt">
          <label for="frameColor">Frame Colour</label>
          <select id="frameColor" data-role="frame-color">
            <option value="black" selected>Black</option>
            <option value="white">White</option>
            <option value="oak">Natural Oak</option>
            <option value="walnut">Walnut</option>
            <option value="gold">Brushed Gold</option>
          </select>
        </div>

        <div class="opt">
          <label for="size">Size</label>
          <select id="size">
            <option value="A4">A4</option>
            <option value="A3">A3</option>
            <option value="A2">A2</option>
            <option value="A1">A1</option>
          </select>
        </div>

        <button type="button">Add to Cart</button>

        <p class="copy" style="margin-top:1.25rem;">
          Minimal, fashion-illustration print framed with a premium mat and your choice of frame. The preview updates to show the selected frame colour.
        </p>
      </section>

    </div>
  </main>

  <script>
  (() => {
    // --- Map product id -> image path the browser can load ---
    const PRODUCT_IMAGE = {
      'women-in-black': '/images/prints/womaninblack.jpg' // change if your path differs
    };
    const DEFAULT_PRODUCT_ID = 'women-in-black';

    // --- Read product id from URL ---
    const id = new URLSearchParams(location.search).get('id') || DEFAULT_PRODUCT_ID;
    const PRINT_SRC = PRODUCT_IMAGE[id] || PRODUCT_IMAGE[DEFAULT_PRODUCT_ID];

    // --- Elements ---
    const canvas = document.getElementById('framePreview');
    const ctx = canvas.getContext('2d', { alpha: true });
    const colorSelect =
      document.getElementById('frameColor') ||
      document.querySelector('select[data-role="frame-color"]');

    // --- Look & proportions ---
    const MAT_RATIO   = 0.10; // 10% mat (mount) around the art
    const FRAME_RATIO = 0.06; // 6% of art width for frame
    const SHADOW_BLUR = 40;
    const matColor = '#ffffff';

    const frameStyles = {
      black:  { base:'#121212', highlight:'#3b3b3b', lowlight:'#000000', grain:'none'   },
      white:  { base:'#f5f5f5', highlight:'#ffffff', lowlight:'#d8d8d8', grain:'none'   },
      oak:    { base:'#c99b52', highlight:'#eecb8a', lowlight:'#8a5f2b', grain:'oak'    },
      walnut: { base:'#6b4526', highlight:'#8f6747', lowlight:'#3e2312', grain:'walnut' },
      gold:   { base:'#c6a64f', highlight:'#f0e2a2', lowlight:'#8f7a3c', grain:'metal'  },
    };

    // --- Load the print image ---
    const artImg = new Image();
    artImg.src = PRINT_SRC;
    artImg.decoding = 'async';
    artImg.onload = () => {
      const ratio = artImg.width / artImg.height;
      resizeCanvas(ratio);
      draw();
      window.addEventListener('resize', () => { resizeCanvas(ratio); draw(); });
    };
    artImg.onerror = () => console.warn('Failed to load image at', PRINT_SRC);

    // Re-draw when frame colour changes
    if (colorSelect) colorSelect.addEventListener('change', draw);

    // --- Drawing functions ---
    function resizeCanvas(imgRatio) {
      const cssW = canvas.clientWidth;
      const cssH = Math.round((cssW / (imgRatio || 0.8)) * (1 + 2*FRAME_RATIO + 2*MAT_RATIO));
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
      canvas.style.height = cssH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function draw() {
      if (!artImg.complete) return;
      const chosen = (colorSelect && colorSelect.value) || 'black';
      const style = frameStyles[chosen] || frameStyles.black;

      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      // wall shadow & crispness
      ctx.filter = `drop-shadow(0px ${Math.max(10, H*0.015)}px ${SHADOW_BLUR}px rgba(0,0,0,0.25))`;

      // layout
      const imgRatio = artImg.width / artImg.height;
      const innerW = W / (1 + 2*FRAME_RATIO + 2*MAT_RATIO);
      const innerH = innerW / imgRatio;
      const matW   = innerW * MAT_RATIO;
      const frameW = innerW * FRAME_RATIO;
      const outerW = innerW + 2*(matW + frameW);
      const outerH = innerH + 2*(matW + frameW);
      const x0 = (W - outerW)/2, y0 = (H - outerH)/2;

      const outer = { x:x0, y:y0, w:outerW, h:outerH };
      const inner = { x:x0+frameW, y:y0+frameW, w:outerW-2*frameW, h:outerH-2*frameW };

      // FRAME base
      roundRect(ctx, outer.x, outer.y, outer.w, outer.h, 6);
      ctx.fillStyle = style.base; ctx.fill();

      // bevels (light from top-left)
      const gradTL = ctx.createLinearGradient(inner.x, inner.y, outer.x, outer.y);
      gradTL.addColorStop(0, rgba(style.highlight, .35));
      gradTL.addColorStop(1, rgba(style.highlight, 0));
      ctx.fillStyle = gradTL;
      ctx.fillRect(outer.x, outer.y, outer.w, frameW);
      ctx.fillRect(outer.x, outer.y, frameW, outer.h);

      const gradBR = ctx.createLinearGradient(inner.x+inner.w, inner.y+inner.h, outer.x+outer.w, outer.y+outer.h);
      gradBR.addColorStop(0, rgba(style.lowlight, .35));
      gradBR.addColorStop(1, rgba(style.lowlight, 0));
      ctx.fillStyle = gradBR;
      ctx.fillRect(outer.x, outer.y+outer.h-frameW, outer.w, frameW);
      ctx.fillRect(outer.x+outer.w-frameW, outer.y, frameW, outer.h);

      // grain
      addGrain(ctx, outer, frameW, style);

      // inner cut glint
      const edge = 2;
      ctx.fillStyle = 'rgba(255,255,255,.25)';
      ctx.fillRect(inner.x - edge, inner.y - edge, inner.w + 2*edge, edge);
      ctx.fillRect(inner.x - edge, inner.y + inner.h, inner.w + 2*edge, edge);
      ctx.fillRect(inner.x - edge, inner.y, edge, inner.h);
      ctx.fillRect(inner.x + inner.w, inner.y, edge, inner.h);

      // MAT
      const mat = { x:inner.x, y:inner.y, w:inner.w, h:inner.h };
      roundRect(ctx, mat.x, mat.y, mat.w, mat.h, 4);
      ctx.fillStyle = '#ffffff'; ctx.fill();

      const matShadow = ctx.createLinearGradient(mat.x, mat.y, mat.x, mat.y + 14);
      matShadow.addColorStop(0, 'rgba(0,0,0,0.18)');
      matShadow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = matShadow;
      ctx.fillRect(mat.x+6, mat.y+6, mat.w-12, 10);

      // ART
      const artRect = { x: mat.x + matW, y: mat.y + matW, w: mat.w - 2*matW, h: mat.h - 2*matW };
      const src = coverRect(artImg.width, artImg.height, artRect.w, artRect.h);

      ctx.save();
      roundRect(ctx, artRect.x, artRect.y, artRect.w, artRect.h, 2);
      ctx.clip();
      ctx.drawImage(artImg, src.sx, src.sy, src.sw, src.sh, artRect.x, artRect.y, artRect.w, artRect.h);
      ctx.restore();

      // subtle glass glare
      const glare = ctx.createLinearGradient(artRect.x, artRect.y, artRect.x+artRect.w, artRect.y+artRect.h);
      glare.addColorStop(0, 'rgba(255,255,255,0.06)');
      glare.addColorStop(0.6, 'rgba(255,255,255,0)');
      ctx.fillStyle = glare;
      ctx.fillRect(artRect.x, artRect.y, artRect.w, artRect.h);

      ctx.restore();
    }

    // helpers
    function roundRect(ctx, x, y, w, h, r) {
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }
    function coverRect(sw, sh, dw, dh) {
      const sr = sw/sh, dr = dw/dh;
      let sx=0, sy=0, sw2=sw, sh2=sh;
      if (sr > dr) { sw2 = sh*dr; sx = (sw - sw2)/2; }
      else { sh2 = sw/dr; sy = (sh - sh2)/2; }
      return { sx, sy, sw: sw2, sh: sh2 };
    }
    function rgba(hex, a) {
      if (hex.length === 4) {
        const r = parseInt(hex[1]+hex[1],16), g = parseInt(hex[2]+hex[2],16), b = parseInt(hex[3]+hex[3],16);
        return `rgba(${r},${g},${b},${a})`;
      }
      const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
      return `rgba(${r},${g},${b},${a})`;
    }
    function addGrain(ctx, outer, frameW, style) {
      if (style.grain === 'none') return;
      const { x, y, w, h } = outer;
      const lines = Math.max(20, Math.floor((w+h)/30));
      ctx.save();
      ctx.globalAlpha = 0.07;
      ctx.beginPath();
      for (let i=0; i<lines; i++) {
        const yy = y + (h * i / lines);
        ctx.moveTo(x + frameW*0.35, yy);
        ctx.lineTo(x + w - frameW*0.35, yy + Math.sin(i*0.6)*2);
      }
      ctx.lineWidth = style.grain === 'metal' ? 0.7 : 1.1;
      ctx.strokeStyle = style.grain === 'metal' ? '#ffffff' : '#2b1a0d';
      ctx.stroke();
      ctx.restore();
    }
  })();
  </script>
</body>
</html>
